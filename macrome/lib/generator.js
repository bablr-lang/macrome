'use strict';

const fs = require('fs');
const { relative, dirname } = require('path');
// const { EOL } = require('os');

const { Matchable } = require('./matchable');
const { debounce } = require('./utils/functional');
const operations = require('./operations');

const { REMOVE } = operations;

const commentLines = [
  'This file is autogenerated. Please do not edit it directly.',
  'When editing run `npx macrome watch` then change the file this is generated from.',
];

class Generator extends Matchable {
  constructor(macrome, options) {
    super();
    this.debouncedMethods = [];
    this._macrome = macrome;
    this.options = options;
    if (!this.options.parser) {
      throw new Error('Generator instantiated without options.parser');
    }
  }

  get operations() {
    return operations;
  }

  get macrome() {
    return this._macrome;
  }

  get parser() {
    return this.options.parser;
  }

  get generatedPaths() {
    return this.macrome.generatedPaths;
  }

  debounce(method) {
    const debounced = debounce(method.bind(this), 50);

    this.debouncedMethods.push(debounced);
    return debounced;
  }

  getDestPath(path) {
    throw new Error('Not implemented');
  }

  process(change) {
    const { path, operation } = change;
    if (this.recordChange) this.recordChange(change);
    if (!this.getDestPath) return;

    const destPath = this.getDestPath(path);

    if (operation === REMOVE) {
      this.unlink(destPath);
    } else {
      let verb;
      let content;
      let isError = false;
      let errorPath = path;
      try {
        verb = 'reading';
        const input = this.read(path);

        verb = 'parsing';
        const inputAst = this.parse(input);

        verb = 'generating';
        errorPath = destPath;
        const ast = this.generatePath({ ast: inputAst, path }, destPath);

        this.decorate(ast, this.getAnnotations(path, destPath));

        verb = 'printing';
        content = this.print(ast).code;
      } catch (e) {
        console.warn(`Failed ${verb} ${errorPath}`);

        isError = true;

        const errorAst = this.generateError(e);

        this.decorate(errorAst, {
          'generate-failed': true,
          ...this.getAnnotations(path, destPath),
        });

        content = this.print(errorAst).code + '\n';
      }

      try {
        this.write(destPath, content);
      } catch (e) {
        console.error(`Failed writing ${isError ? 'error ' : ''}to ${destPath}`);
        throw e;
      }
    }
  }

  /**
   * Given a file prepends annotation comments to the initial doc comment block, creating an
   * initial comment if necessary. Assumes a javascript-like comment and annotation sytnax.
   * To support other syntaxes, override.
   */
  decorate(ast, annotations) {
    this.parser.stripHeader(ast);
    this.parser.prependHeader(ast, annotations, commentLines);
  }

  getAnnotations(sourcePath, destPath) {
    const relPath = relative(dirname(destPath), sourcePath);
    return {
      macrome: true,
      'generated-from': relPath.startsWith('.') ? relPath : `./${relPath}`,
    };
  }

  resolve(path) {
    return this.macrome.resolve(path);
  }

  read(path) {
    return fs.readFileSync(this.macrome.resolve(path), 'utf8');
  }

  parse(content) {
    return this.parser.parse(content, this.options.parseOptions);
  }

  print(ast) {
    return this.parser.print(ast, this.options.printOptions);
  }

  generateError(e) {
    return this.parser.generateError(e);
  }

  write(path, content) {
    this.macrome.write(path, content);
  }

  unlink(path) {
    this.macrome.unlink(path);
  }

  log(...args) {
    this.macrome.log(...args);
  }

  writeMonolithic(path, content) {
    if (this.generatedPaths.isStale(path, content)) {
      fs.writeFileSync(this.resolve(path), content);
      this.generatedPaths.cache(path, { monolithic: true });
    }
  }
}

module.exports = { Generator };
