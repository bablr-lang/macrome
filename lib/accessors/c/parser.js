"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CCommentParser = void 0;
const iter_tools_es_1 = require("iter-tools-es");
const rd_parse_1 = require("@conartist6/rd-parse");
const defaultContent = [
    'This file is autogenerated. Please do not edit it directly.',
    'When editing run `npx macrome watch` then change the file this is generated from.',
].join('\n');
const _ = (0, rd_parse_1.Optional)((0, rd_parse_1.Ignore)(/[ \t]+/));
const key = /[a-zA-Z-]+/;
const value = /([^*\n]|\*(?!\/))*/;
const annotation = (0, rd_parse_1.Node)((0, rd_parse_1.All)(_, (0, rd_parse_1.Optional)('*'), _, '@', key, _, (0, rd_parse_1.Optional)(value), _, (0, rd_parse_1.Optional)('\n')), ([key, value]) => [key, value.trimEnd() || true]);
const annotations = (0, rd_parse_1.Node)((0, rd_parse_1.Star)(annotation), (entries) => new Map(entries));
const commentLinePrefix = / *\* ?/;
const commentLineContent = /([^*\n]|\*(?!\/))*/; // allow * but not */
const commentLine = (0, rd_parse_1.All)((0, rd_parse_1.Optional)((0, rd_parse_1.Ignore)(commentLinePrefix)), commentLineContent, '\n');
const commentLines = (0, rd_parse_1.Node)((0, rd_parse_1.All)((0, rd_parse_1.Star)(commentLine)), (commentLines) => commentLines);
const comment = (0, rd_parse_1.Node)((0, rd_parse_1.All)(_, '/*', annotations, commentLines, (0, rd_parse_1.Optional)(/ */), '*/', _), ([annotations, commentLines]) => ({ annotations, content: commentLines.join('\n') }));
function renderAnnotation([key, value]) {
    return `@${key}${value === true ? '' : ` ${value}`}`;
}
class CCommentParser {
    constructor() {
        this._parser = new rd_parse_1.Parser(comment);
    }
    parse(text) {
        return this._parser.parse(text);
    }
    print({ annotations, content = defaultContent }) {
        const body = (0, iter_tools_es_1.execPipe)(annotations, (0, iter_tools_es_1.map)((ann) => ` * ${renderAnnotation(ann)}`), (0, iter_tools_es_1.joinWithSeq)('\n'), iter_tools_es_1.str);
        const comments = content.length
            ? '\n' +
                content
                    .split('\n')
                    .map((l) => ` * ${l}`)
                    .join('\n')
            : '';
        return `/${body.slice(1)}${comments}\n */`;
    }
}
exports.CCommentParser = CCommentParser;
