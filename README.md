# Macromé

Macromé (pronounced macro-may) is a build tool designed for generating files which will be checked into source control. This differs from existing build systems like grunt, gulp, or broccoli, all of which are designed to generate built outputs which will not be checked in.

**Macromé is not intended to replace other existing build systems**. It is intended to supplement them. You won't find plugins for compiling to CSS or es5, or bundling assets. You should still use another build system for those tasks.

Nothing about Macromé is specific to Javascript, but it is expected to be used mostly on Javascript projects, particularly in combination with the excellent `babel-plugin-macros`.

Macromé is designed to run either in a CI environment (so you can verify that no assets are stale), or locally. When running locally Macromé can watch your files for changes if you have [watchman](http://facebook.github.io/watchman/docs/install) installed.

## Usage

```
npx macrome [command] [options]

Commands:
  build                     Run macrome generators (the default)
  watch                     Build then then perform incremental rebuilds on changes
  clean                     Delete files create by macrome generators
  check                     Builds then exits with 0 if no files were changed

Options:
  -q, --quiet               Only log errors
  -h, --help                Print this message

Exit codes:
  0 Success
  1 Unknown error
  2 Unknown command
  3 `check` command found changed files

Watching options
  --watchman-path           Path to a watchman binary
```

Macrome can also be imported and used in scripts (though CLI usage is preferred).

```js
const { Macrome } = require('macrome');

const macrome = new Macrome(configOptions); // same as cli options, but camel case
macrome.clean();
macrome.build();
macrome.watch();
```

## Why would I need Macromé?

Macros are a time-tested and potentially highly useful technique, but they come with certain problems. Most importantly they complicate the history of the codebase because the macros-applied code, suitable for execution and static analysis, isn't usually under source control. This means you can no longer read past code unless you understand the historical definition of any macros.

Macrome helps you maintain that history for the benefit of future readers, which should even enable git commit hashes to be used as ad hoc packages.

## Features

- It can easily mark its output files as being autogenerated, omitting them from review on github
- It's safe to leave running in watch mode, even during version control operations
- It can clean all autogenerated files
- When generation fails, the generated file throws the relevant error at parse-time
- Supports monorepos
